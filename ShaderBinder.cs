/* 
 * ShaderBinder utility library
 * (c) 2021 Mikko Strandborg
 * 
 * Licensed under the Boost Software License 1.0
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 * 
 */



using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Rendering;
using System;
using System.Reflection;

namespace ShaderBinding
{

    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Property, AllowMultiple = true)]
    public class ShaderValueAttribute : Attribute
    {
        public ShaderValueAttribute()
        { }

        public string Target { get; set; }
    }

    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Property, AllowMultiple = true)]
    public class ShaderKeywordAttribute : Attribute
    {
        public ShaderKeywordAttribute() { }

        public string Target { get; set; }
    }


    internal class ShaderBinder
    {
        private struct ValInfo
        {
            public enum Type
            {
                Invalid,
                Float,
                Int,
                Vector3,
                Vector4,
                FloatArray,
                VectorArray,
                Matrix,
                MatrixArray,
                Texture,
                ComputeBuffer,
                GraphicsBuffer
            };

            public Type type;
            public int shaderID;
        };

        private List<(FieldInfo, ValInfo)> m_Values = new List<(FieldInfo, ValInfo)>();
        private List<(PropertyInfo, ValInfo)> m_PropValues = new List<(PropertyInfo, ValInfo)>();
        private List<(FieldInfo, string)> m_Keywords = new List<(FieldInfo, string)>();
        private List<(PropertyInfo, string)> m_PropKeywords = new List<(PropertyInfo, string)>();

        private static ValInfo.Type ConvertType(Type t)
        {
            if (t == typeof(int))
                return ValInfo.Type.Int;
            else if (t == typeof(float))
                return ValInfo.Type.Float;
            else if (t == typeof(Vector3))
                return ValInfo.Type.Vector3;
            else if (t == typeof(Vector4))
                return ValInfo.Type.Vector4;
            else if (t == typeof(float[]))
                return ValInfo.Type.FloatArray;
            else if (t == typeof(Vector4[]))
                return ValInfo.Type.VectorArray;
            else if (t == typeof(Matrix4x4))
                return ValInfo.Type.Matrix;
            else if (t == typeof(Matrix4x4[]))
                return ValInfo.Type.MatrixArray;
            else if (typeof(Texture).IsAssignableFrom(t))
                return ValInfo.Type.Texture;
            else if (t == typeof(ComputeBuffer))
                return ValInfo.Type.ComputeBuffer;
            else if (t == typeof(GraphicsBuffer))
                return ValInfo.Type.GraphicsBuffer;
            else
                return ValInfo.Type.Invalid;

        }

        public void Init(Type t)
        {
            var fields = t.GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static);

            foreach (var field in fields)
            {
                var attrs = field.GetCustomAttributes(typeof(ShaderValueAttribute), true);
                foreach (var _attr in attrs)
                {
                    var attr = _attr as ShaderValueAttribute;

                    string name = field.Name;
                    if (name.StartsWith("m_"))
                        name = name.Remove(0, 2);
                    if (attr.Target != null)
                        name = attr.Target;

                    var vi = new ValInfo() { type = ConvertType(field.FieldType), shaderID = Shader.PropertyToID(name) };

                    if (vi.type != ValInfo.Type.Invalid)
                        m_Values.Add((field, vi));
                }

                attrs = field.GetCustomAttributes(typeof(ShaderKeywordAttribute), true);
                foreach (var _attr in attrs)
                {
                    var attr = _attr as ShaderKeywordAttribute;
                    string name = field.Name;
                    if (name.StartsWith("m_"))
                        name = name.Remove(0, 2);
                    if (attr.Target != null)
                        name = attr.Target;

                    if (field.FieldType == typeof(bool))
                    {
                        m_Keywords.Add((field, name));
                    }
                }
            }

            var props = t.GetProperties(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
            foreach (var prop in props)
            {
                var attrs = prop.GetCustomAttributes(typeof(ShaderValueAttribute), true);
                foreach (var _attr in attrs)
                {
                    var attr = _attr as ShaderValueAttribute;

                    string name = prop.Name;
                    if (name.StartsWith("m_"))
                        name = name.Remove(0, 2);
                    if (attr.Target != null)
                        name = attr.Target;

                    var vi = new ValInfo() { type = ConvertType(prop.PropertyType), shaderID = Shader.PropertyToID(name) };

                    if (vi.type != ValInfo.Type.Invalid)
                        m_PropValues.Add((prop, vi));

                }

                attrs = prop.GetCustomAttributes(typeof(ShaderKeywordAttribute), true);
                foreach (var _attr in attrs)
                {
                    var attr = _attr as ShaderKeywordAttribute;
                    string name = prop.Name;
                    if (name.StartsWith("m_"))
                        name = name.Remove(0, 2);
                    if (attr.Target != null)
                        name = attr.Target;

                    if (prop.PropertyType == typeof(bool))
                    {
                        m_PropKeywords.Add((prop, name));
                    }
                }
            }
        }

        private void Apply(Material mat, ValInfo vi, object val)
        {
            switch (vi.type)
            {
                case ValInfo.Type.Int:
                    mat.SetInt(vi.shaderID, (int)val);
                    break;
                case ValInfo.Type.Float:
                    mat.SetFloat(vi.shaderID, (float)val);
                    break;
                case ValInfo.Type.Vector3:
                    mat.SetVector(vi.shaderID, (Vector3)val);
                    break;
                case ValInfo.Type.Vector4:
                    mat.SetVector(vi.shaderID, (Vector4)val);
                    break;
                case ValInfo.Type.FloatArray:
                    mat.SetFloatArray(vi.shaderID, (float[])val);
                    break;
                case ValInfo.Type.VectorArray:
                    mat.SetVectorArray(vi.shaderID, (Vector4[])val);
                    break;
                case ValInfo.Type.Matrix:
                    mat.SetMatrix(vi.shaderID, (Matrix4x4)val);
                    break;
                case ValInfo.Type.MatrixArray:
                    mat.SetMatrixArray(vi.shaderID, (Matrix4x4[])val);
                    break;
                case ValInfo.Type.Texture:
                    mat.SetTexture(vi.shaderID, (Texture)val);
                    break;
                case ValInfo.Type.ComputeBuffer:
                    mat.SetBuffer(vi.shaderID, (ComputeBuffer)val);
                    break;
                case ValInfo.Type.GraphicsBuffer:
                    mat.SetBuffer(vi.shaderID, (GraphicsBuffer)val);
                    break;
                case ValInfo.Type.Invalid:
                default:
                    break;
            }
        }
        private void Apply(MaterialPropertyBlock mat, ValInfo vi, object val)
        {
            switch (vi.type)
            {
                case ValInfo.Type.Int:
                    mat.SetInt(vi.shaderID, (int)val);
                    break;
                case ValInfo.Type.Float:
                    mat.SetFloat(vi.shaderID, (float)val);
                    break;
                case ValInfo.Type.Vector3:
                    mat.SetVector(vi.shaderID, (Vector3)val);
                    break;
                case ValInfo.Type.Vector4:
                    mat.SetVector(vi.shaderID, (Vector4)val);
                    break;
                case ValInfo.Type.FloatArray:
                    mat.SetFloatArray(vi.shaderID, (float[])val);
                    break;
                case ValInfo.Type.VectorArray:
                    mat.SetVectorArray(vi.shaderID, (Vector4[])val);
                    break;
                case ValInfo.Type.Matrix:
                    mat.SetMatrix(vi.shaderID, (Matrix4x4)val);
                    break;
                case ValInfo.Type.MatrixArray:
                    mat.SetMatrixArray(vi.shaderID, (Matrix4x4[])val);
                    break;
                case ValInfo.Type.Texture:
                    mat.SetTexture(vi.shaderID, (Texture)val);
                    break;
                case ValInfo.Type.ComputeBuffer:
                    mat.SetBuffer(vi.shaderID, (ComputeBuffer)val);
                    break;
                case ValInfo.Type.GraphicsBuffer:
                    mat.SetBuffer(vi.shaderID, (GraphicsBuffer)val);
                    break;
                case ValInfo.Type.Invalid:
                default:
                    break;
            }
        }
        private void Apply(ComputeShader mat, int[] kernelIndices, ValInfo vi, object val)
        {
            switch (vi.type)
            {
                case ValInfo.Type.Int:
                    mat.SetInt(vi.shaderID, (int)val);
                    break;
                case ValInfo.Type.Float:
                    mat.SetFloat(vi.shaderID, (float)val);
                    break;
                case ValInfo.Type.Vector3:
                    mat.SetVector(vi.shaderID, (Vector3)val);
                    break;
                case ValInfo.Type.Vector4:
                    mat.SetVector(vi.shaderID, (Vector4)val);
                    break;
                case ValInfo.Type.FloatArray:
                    //                mat.SetFloatArray(vi.shaderID, (float[])val);
                    break;
                case ValInfo.Type.VectorArray:
                    mat.SetVectorArray(vi.shaderID, (Vector4[])val);
                    break;
                case ValInfo.Type.Matrix:
                    mat.SetMatrix(vi.shaderID, (Matrix4x4)val);
                    break;
                case ValInfo.Type.MatrixArray:
                    mat.SetMatrixArray(vi.shaderID, (Matrix4x4[])val);
                    break;
                case ValInfo.Type.Texture:
                    foreach (int k in kernelIndices)
                        mat.SetTexture(k, vi.shaderID, (Texture)val);
                    break;
                case ValInfo.Type.ComputeBuffer:
                    foreach (int k in kernelIndices)
                        mat.SetBuffer(k, vi.shaderID, (ComputeBuffer)val);
                    break;
                case ValInfo.Type.GraphicsBuffer:
                    foreach (int k in kernelIndices)
                        mat.SetBuffer(k, vi.shaderID, (GraphicsBuffer)val);
                    break;
                case ValInfo.Type.Invalid:
                default:
                    break;
            }
        }

        public void Apply(object parent, Material mat)
        {
            foreach ((FieldInfo f, ValInfo vi) in m_Values)
            {
                Apply(mat, vi, f.GetValue(parent));
            }
            foreach ((PropertyInfo p, ValInfo vi) in m_PropValues)
            {
                Apply(mat, vi, p.GetValue(parent));
            }

            foreach ((FieldInfo f, string name) in m_Keywords)
            {
                var isEnabled = (bool)f.GetValue(parent);
                if (isEnabled)
                    mat.EnableKeyword(name);
                else
                    mat.DisableKeyword(name);
            }
            foreach ((PropertyInfo p, string name) in m_PropKeywords)
            {
                var isEnabled = (bool)p.GetValue(parent);
                if (isEnabled)
                    mat.EnableKeyword(name);
                else
                    mat.DisableKeyword(name);
            }
        }

        public void Apply(object parent, MaterialPropertyBlock mat)
        {
            foreach ((FieldInfo f, ValInfo vi) in m_Values)
            {
                Apply(mat, vi, f.GetValue(parent));
            }
            foreach ((PropertyInfo p, ValInfo vi) in m_PropValues)
            {
                Apply(mat, vi, p.GetValue(parent));
            }
        }

        public void Apply(object parent, ComputeShader mat, params int[] kernelIndices)
        {
            foreach ((FieldInfo f, ValInfo vi) in m_Values)
            {
                Apply(mat, kernelIndices, vi, f.GetValue(parent));
            }
            foreach ((PropertyInfo p, ValInfo vi) in m_PropValues)
            {
                Apply(mat, kernelIndices, vi, p.GetValue(parent));
            }

            foreach ((FieldInfo f, string name) in m_Keywords)
            {
                var isEnabled = (bool)f.GetValue(parent);
                if (isEnabled)
                    mat.EnableKeyword(name);
                else
                    mat.DisableKeyword(name);
            }
            foreach ((PropertyInfo p, string name) in m_PropKeywords)
            {
                var isEnabled = (bool)p.GetValue(parent);
                if (isEnabled)
                    mat.EnableKeyword(name);
                else
                    mat.DisableKeyword(name);
            }
        }

    }

    public static class ShaderBinderExtensions
    {
        private static Dictionary<Type, ShaderBinder> m_Binders = new Dictionary<Type, ShaderBinder>();

        private static ShaderBinder FindOrCreateBinder(Type t)
        {
            if (m_Binders.TryGetValue(t, out var res))
                return res;

            res = new ShaderBinder();
            res.Init(t);
            m_Binders.Add(t, res);
            return res;
        }

        public static void ApplyShaderProps<T>(this T me, Material mat)
        {
            var b = FindOrCreateBinder(typeof(T));
            b.Apply(me, mat);
        }
        public static void ApplyShaderProps<T>(this T me, MaterialPropertyBlock mat)
        {
            var b = FindOrCreateBinder(typeof(T));
            b.Apply(me, mat);
        }
        public static void ApplyShaderProps<T>(this T me, ComputeShader mat, params int[] kernelIndices)
        {
            var b = FindOrCreateBinder(typeof(T));
            b.Apply(me, mat, kernelIndices);
        }
    }

}